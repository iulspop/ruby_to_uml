<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Diagram</title>
</head>
<body>
  <script src="//unpkg.com/graphre/dist/graphre.js"></script>
  <script src="//unpkg.com/nomnoml/dist/nomnoml.js"></script>

  <canvas id="target-canvas"></canvas>
  <script>
      var canvas = document.getElementById('target-canvas');
      var source = `#direction: right
#zoom: 0.9

#font: Roboto
#fontSize: 20
#leading: 2
#padding: 12

#fillArrows: true
#arrowSize: 0.5
#spacing: 130

#lineWidth: 1.5
#stroke: #33322E

#.class: fill=#FEDCC4 title=bold
#.module: fill=#D9E6FF title=bold
[<class> Hoe |
   |
   |
  
]
[<class> Runnable |
   |
  +time_it; +name; +name=(o); +marshal_dump; +marshal_load(ary); +failure; +initialize(name); +run; +passed?; +result_code; +skipped? |
  self.methods_matching(re); self.reset; self.run(reporter, options); self.run_one_method(klass, method_name, reporter); self.with_info_handler(reporter, block); self.on_signal(name, action); self.runnable_methods; self.runnables; self.inherited(klass)
]
[<class> Result |
   |
  +class_name; +to_s |
  self.from(runnable)
]
[<class> AbstractReporter |
   |
  +start; +prerecord(klass, name); +record(result); +report; +passed? |
  
]
[<class> Reporter |
   |
  +initialize(io, options) |
  
]
[<class> ProgressReporter |
   |
  +prerecord(klass, name); +record(result) |
  
]
[<class> StatisticsReporter |
   |
  +initialize(io, options); +passed?; +start; +record(result); +report |
  
]
[<class> SummaryReporter |
   |
  +start; +report; +statistics; +aggregated_results(io); +to_s; +summary |
  
]
[<class> CompositeReporter |
   |
  +initialize(reporters); +io; +<<(reporter); +passed?; +start; +prerecord(klass, name); +record(result); +report |
  
]
[<class> Assertion |
   |
  +error; +location; +result_code; +result_label |
  
]
[<class> Skip |
   |
  +result_label |
  
]
[<class> UnexpectedError |
   |
  +initialize(error); +backtrace; +message; +result_label |
  
]
[<class> BacktraceFilter |
   |
  +filter(bt) |
  
]
[<class> Benchmark |
   |
  +io; +assert_performance(validation, work); +assert_performance_constant(threshold, work); +assert_performance_exponential(threshold, work); +assert_performance_logarithmic(threshold, work); +assert_performance_linear(threshold, work); +assert_performance_power(threshold, work); +fit_error(xys); +fit_exponential(xs, ys); +fit_logarithmic(xs, ys); +fit_linear(xs, ys); +fit_power(xs, ys); +sigma(enum, block); +validation_for_fit(msg, threshold) |
  self.io; self.run(reporter, options); self.runnable_methods; self.bench_exp(min, max, base); self.bench_linear(min, max, step); self.bench_range
]
[<class> BenchSpec |
   |
   |
  self.bench(name, block); self.bench_range(block); self.bench_performance_linear(name, threshold, work); self.bench_performance_constant(name, threshold, work); self.bench_performance_exponential(name, threshold, work); self.bench_performance_logarithmic(name, threshold, work); self.bench_performance_power(name, threshold, work)
]
[<class> Test |
   |
  +class_name; +run; +capture_exceptions; +with_info_handler(block) |
  self.i_suck_and_my_tests_are_order_dependent!; self.make_my_diffs_pretty!; self.parallelize_me!; self.runnable_methods; self.test_order
]
[<class> MockExpectationError |
   |
   |
  
]
[<class> Mock |
  @delegator; @expected_calls; @actual_calls |
  +initialize(delegator); +expect(name, retval, args, blk); +__call(name, data); +verify; +method_missing(sym, args, block); +respond_to?(sym, include_private) |
  
]
[<class> Object |
   |
  +stub(name, val_or_callable, block_args) |
  
]
[<class> Executor |
  @size; @queue; @pool |
  +initialize(size); +start; +<<(work); +shutdown |
  
]
[<class> PrideIO |
  @io; @size; @index |
  +initialize(io); +print(o); +puts(o); +pride(string); +method_missing(msg, args) |
  self.pride!; self.pride?
]
[<class> PrideLOL |
  @colors |
  +initialize(io); +pride(string) |
  
]
[<class> Module |
   |
  +infect_an_assertion(meth, new_name, dont_flip) |
  
]
[<class> Spec |
   |
  +initialize(name) |
  self.current
]
[<class> Unit |
   |
   |
  self.autorun; self.after_tests(b)
]
[<class> TestCase |
   |
   |
  self.inherited(klass)
]
[<module> Minitest |
  +minitest?; +initialize_minitest; +define_minitest_tasks |
  self.autorun; self.after_run(block); self.init_plugins(options); self.load_plugins; self.run(args); self.__run(reporter, options); self.process_args(args); self.filter_backtrace(bt); self.run_one_method(klass, method_name); self.plugin_pride_options(opts, _options); self.plugin_pride_init(options)
]
[<module> Reportable |
  +passed?; +location; +class_name; +result_code; +skipped?; +error? |
  
]
[<module> Guard |
  +jruby?(platform); +maglev?(platform); +mri?(platform); +osx?(platform); +rubinius?(platform); +windows?(platform) |
  
]
[<module> Assertions |
  +diff(exp, act); +things_to_diff(exp, act); +mu_pp(obj); +mu_pp_for_diff(obj); +assert(test, msg); +_synchronize; +assert_empty(obj, msg); +assert_equal(exp, act, msg); +assert_in_delta(exp, act, delta, msg); +assert_in_epsilon(exp, act, epsilon, msg); +assert_includes(collection, obj, msg); +assert_instance_of(cls, obj, msg); +assert_kind_of(cls, obj, msg); +assert_match(matcher, obj, msg); +assert_nil(obj, msg); +assert_operator(o1, op, o2, msg); +assert_output(stdout, stderr); +assert_path_exists(path, msg); +assert_predicate(o1, op, msg); +assert_raises(exp); +assert_respond_to(obj, meth, msg); +assert_same(exp, act, msg); +assert_send(send_ary, m); +assert_silent; +assert_throws(sym, msg); +capture_io; +capture_subprocess_io; +exception_details(e, msg); +fail_after(y, m, d, msg); +flunk(msg); +message(msg, ending, default); +pass(_msg); +refute(test, msg); +refute_empty(obj, msg); +refute_equal(exp, act, msg); +refute_in_delta(exp, act, delta, msg); +refute_in_epsilon(a, b, epsilon, msg); +refute_includes(collection, obj, msg); +refute_instance_of(cls, obj, msg); +refute_kind_of(cls, obj, msg); +refute_match(matcher, obj, msg); +refute_nil(obj, msg); +refute_operator(o1, op, o2, msg); +refute_path_exists(path, msg); +refute_predicate(o1, op, msg); +refute_respond_to(obj, meth, msg); +refute_same(exp, act, msg); +skip(msg, bt); +skip_until(y, m, d, msg); +skipped?; +assert_mock(mock) |
  self.inspect; self.diff; self.diff=(o)
]
[<module> Expectations |
   |
  
]
[<module> Parallel |
   |
  
]
[<module> Test |
  +_synchronize |
  
]
[<module> ClassMethods |
  +run_one_method(klass, method_name, reporter); +test_order |
  
]
[<module> Kernel |
  +describe(desc, additional_desc, block) |
  
]
[<module> DSL |
  +register_spec_type(args, block); +spec_type(desc, additional); +describe_stack; +children; +nuke_test_methods!; +before(_type, block); +after(_type, block); +it(desc, block); +let(name, block); +subject(block); +create(name, desc); +name; +to_s |
  self.extended(obj)
]
[<module> InstanceMethods |
  +_(value, block); +before_setup |
  
]
[<module> LifecycleHooks |
  +before_setup; +setup; +after_setup; +before_teardown; +teardown; +after_teardown |
  
]
[Result] inherits <:- [Runnable]
[Result] includes <- [Reportable]
[AbstractReporter] includes <- [Mutex_m]
[Reporter] inherits <:- [AbstractReporter]
[ProgressReporter] inherits <:- [Reporter]
[StatisticsReporter] inherits <:- [Reporter]
[SummaryReporter] inherits <:- [StatisticsReporter]
[CompositeReporter] inherits <:- [AbstractReporter]
[Assertion] inherits <:- [Exception]
[Skip] inherits <:- [Assertion]
[UnexpectedError] inherits <:- [Assertion]
[Benchmark] inherits <:- [Test]
[BenchSpec] inherits <:- [Benchmark]
[BenchSpec] extends <- [DSL]
[MockExpectationError] inherits <:- [StandardError]
[PrideLOL] inherits <:- [PrideIO]
[Spec] inherits <:- [Test]
[Spec] extends <- [DSL]
[Test] inherits <:- [Runnable]
[Test] includes <- [Assertions]
[Test] includes <- [Reportable]
[Test] includes <- [LifecycleHooks]
[Test] includes <- [Guard]
[Test] extends <- [Guard]
[TestCase] inherits <:- [Test]
`;
      nomnoml.draw(canvas, source);
  </script>
</body>
</html>